<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Cocai Play</title>
    <!-- Bootstrap CSS via CDN for faster prototyping and consistent UI -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
      /* Viewport-sized app shell with no body scrollbars */
      html, body { height: 100%; }
      html { box-sizing: border-box; }
      *, *::before, *::after { box-sizing: inherit; }
      body {
        margin: 0;
        min-height: 100vh;
        overflow: hidden; /* no page scrollbars; panes will scroll internally */
      }
      :root {
        --bg: #0e0e10;
        --panel: #17171a;
        --panel-2: #1f1f24;
        --text: #e7e7ea;
        --muted: #a4a4ae;
        --primary: #7c5cff;
        --border: #2a2a31;
      }
      body { background: linear-gradient(180deg, #0b0b0d 0%, #0e0e10 100%); color: var(--text); font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; }
      /* Keep small component styles while allowing Bootstrap to handle layout */
      .panel-card { background: var(--panel); border: 1px solid var(--border); border-radius: 10px; overflow: hidden; }
      .panel-card .card-header { background: var(--panel-2); border-bottom: 1px solid var(--border); font-weight: 600; }
      .muted { color: var(--muted); }
      .placeholder { color: var(--muted); font-style: italic; padding: 6px 2px; }
      #illustration { background: radial-gradient(80% 70% at 50% 30%, #1b1b21, #121216 70%); display:flex; align-items:center; justify-content:center; }
      #illustration img { max-width:100%; max-height:100%; object-fit:contain; }
  /* Accordion overrides (kept simple) */
      .acc-item { border: 1px solid var(--border); border-radius: 8px; overflow: hidden; background: #141418; }
  .acc-summary { width: 100%; text-align: left; padding: 10px 12px; background: #18181d; color: var(--text); border: none; outline: none; cursor: pointer; font-weight: 600; display:flex; justify-content:space-between; align-items:center; }
  .acc-body { padding: 10px 12px; color:var(--muted); border-top:1px solid var(--border); }
  .acc-item .btn-toggle:focus { outline: 2px solid rgba(124,92,255,0.35); outline-offset: 2px; }
      .tag { display:inline-block; padding:2px 8px; font-size:11px; color:#c9d1ff; background:rgba(124,92,255,0.12); border:1px solid rgba(124,92,255,0.35); border-radius:999px; margin-left:8px; }
      /* IDE-like layout using Split.js */
  .app-root { height: 100vh; width: 100vw; display: flex; padding: 8px; }
      .column { height: 100%; min-width: 160px; overflow: hidden; display: flex; flex-direction: column; }
  .split-vertical { flex: 1 1 auto; min-height: 0; display: flex; flex-direction: column; }
      .pane { min-height: 0; display: flex; flex-direction: column; }
      .pane.scrollable { overflow: auto; }
      .panel-card.fill { height: 100%; display: flex; flex-direction: column; }
      .panel-card .panel-body { flex: 1 1 auto; min-height: 0; overflow: auto; }

      /* Gutters for Split.js */
      .gutter { background: var(--border); opacity: 0.9; background-clip: padding-box; }
      .gutter.gutter-horizontal { width: 6px; cursor: col-resize; }
      .gutter.gutter-vertical { height: 6px; cursor: row-resize; }
      /* Make gutters a bit easier to grab */
      .gutter.gutter-horizontal:hover,
      .gutter.gutter-vertical:hover { background: #3a3a44; }

      /* Ensure images/iframes fit inside panes */
      #illustration, #chat { height: 100%; }
      #chat iframe { width: 100%; height: 100%; display: block; }

      /* Responsive: collapse side columns on narrow screens */
      @media (max-width: 1000px) {
        #col-left, #col-right { display: none; }
        .gutter.gutter-horizontal { display: none !important; }
      }

    </style>
  </head>
  <body>
    <div id="app" class="app-root">
      <!-- Left column: History / Clues (resizable vertically) -->
      <div id="col-left" class="column">
        <div id="left-split" class="split-vertical">
          <section id="left-history" class="pane">
            <div class="panel-card fill">
              <div class="card-header">History</div>
              <div class="panel-body p-3">
                <div id="history" class="muted"></div>
              </div>
            </div>
          </section>
          <section id="left-clues" class="pane">
            <div class="panel-card fill">
              <div class="card-header">Clues</div>
              <div class="panel-body p-3">
                <div id="clues" class="accordion"></div>
              </div>
            </div>
          </section>
        </div>
      </div>

      <!-- Center column: Illustration / Chat (resizable vertically) -->
      <div id="col-center" class="column">
        <div id="center-split" class="split-vertical">
          <section id="illustration" class="panel-card fill">
            <img id="scene-image" alt="Scene illustration" />
          </section>
          <section id="chat" class="panel-card fill p-0">
            <iframe src="/chat" title="Cocai Chat"></iframe>
          </section>
        </div>
      </div>

      <!-- Right column: PC panel with resizable Stats / Skills -->
      <div id="col-right" class="column">
        <aside id="right" class="panel-card fill p-0" style="display:flex; flex-direction:column;">
          <div id="pc-header" class="card-header">
            <div id="pc-name">Investigator</div>
          </div>
          <div id="right-split" class="split-vertical" style="flex:1 1 auto; min-height:0;">
            <div id="right-stats-pane" class="pane scrollable">
              <div id="pc-stats" class="p-3"></div>
            </div>
            <div id="right-skills-pane" class="pane scrollable" style="border-top:1px solid var(--border);">
              <div id="skills" class="p-3"></div>
            </div>
          </div>
        </aside>
      </div>
    </div>

  <!-- Bootstrap JS (includes Popper) for collapse/interactive components -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/split.js@1.6.0/dist/split.min.js"></script>

  <script>
      async function fetchState() {
        const res = await fetch('/api/state');
        if (!res.ok) return null;
        return res.json();
      }

      function renderHistory(history) {
        document.getElementById('history').textContent = history || '';
      }

      function renderClues(clues) {
        const container = document.getElementById('clues');
        container.innerHTML = '';
        (clues || []).forEach((c, idx) => {
          const id = `clue-${idx}`;
          const item = document.createElement('div');
          item.className = 'acc-item mb-2';

          // Button that controls the Bootstrap collapse
          const btn = document.createElement('button');
          btn.className = 'acc-summary btn btn-toggle';
          btn.setAttribute('type', 'button');
          btn.setAttribute('data-bs-toggle', 'collapse');
          btn.setAttribute('data-bs-target', `#${id}`);
          btn.setAttribute('aria-expanded', 'false');
          btn.setAttribute('aria-controls', id);
          btn.innerHTML = `<span>${c.title}</span><span class="tag">${c.found_at || 'Unknown'}</span>`;

          const bodyWrap = document.createElement('div');
          bodyWrap.className = 'collapse acc-body';
          bodyWrap.id = id;
          bodyWrap.setAttribute('role', 'region');
          bodyWrap.setAttribute('aria-labelledby', id + '-label');
          const body = document.createElement('div');
          body.id = id + '-label';
          body.textContent = c.content;
          bodyWrap.appendChild(body);

          item.appendChild(btn);
          item.appendChild(bodyWrap);
          container.appendChild(item);
        });
      }

      function renderIllustration(url) {
        const img = document.getElementById('scene-image');
        if (url) img.src = url; else img.removeAttribute('src');
      }

      function renderPC(pc) {
        document.getElementById('pc-name').textContent = pc?.name || 'Investigator';
        const stats = document.getElementById('pc-stats');
        stats.innerHTML = '';
        const statEntries = Object.entries(pc?.stats || {});
        if (statEntries.length) {
          statEntries.forEach(([k,v])=>{
            const d = document.createElement('div');
            d.className = 'stat';
            d.innerHTML = `<span>${k}</span><span>${v}</span>`;
            stats.appendChild(d);
          });
        } else {
          const hint = document.createElement('div');
          hint.className = 'placeholder';
          hint.textContent = 'Create a character to see stats.';
          stats.appendChild(hint);
        }
        const skills = document.getElementById('skills');
        skills.innerHTML = '';
        const skillEntries = Object.entries(pc?.skills || {});
        if (skillEntries.length) {
          skillEntries.forEach(([k,v])=>{
            const row = document.createElement('div');
            row.className = 'skill';
            const label = document.createElement('div');
            label.textContent = `${k}`;
            const right = document.createElement('div');
            right.style.display = 'flex';
            right.style.gap = '8px';
            const val = document.createElement('span');
            val.className = 'muted';
            val.textContent = v;
            right.appendChild(val);
                const btn = document.createElement('button');
                btn.className = 'btn btn-sm btn-outline-light';
                btn.textContent = 'Roll';
                btn.title = `Roll a skill check of ${k}`;
                btn.addEventListener('click', async () => {
                  const msg = `Roll a skill check of ${k}.`;
                  try {
                    await sendMessageToChat(msg);
                  } catch (e) {
                    // As a fallback, try opening the dice window if configured (optional)
                    // openDiceWindow(`/roll_dice?d10=2`);
                    console.warn('Failed to send message to chat:', e);
                    alert('Could not reach the chat composer. Make sure the chat is loaded.');
                  }
                });
                right.appendChild(btn);
            row.appendChild(label);
            row.appendChild(right);
            skills.appendChild(row);
          });
        }
      }

      function openDiceWindow(url) {
        try { window.open(url, '_blank', 'width=420,height=320'); } catch(e) {}
      }

      function listenEvents() {
        try {
          const es = new EventSource('/api/events');
          es.onmessage = (ev) => {
            try {
              const msg = JSON.parse(ev.data);
              if (msg.type === 'history') {
                renderHistory(msg.history);
              } else if (msg.type === 'clues') {
                renderClues(msg.clues);
              } else if (msg.type === 'illustration') {
                renderIllustration(msg.url);
              } else if (msg.type === 'pc') {
                renderPC(msg.pc);
              } else if (msg.type === 'server_shutdown') {
                try { es.close(); } catch(e) {}
                const iframe = document.querySelector('#chat iframe');
                if (iframe) iframe.src = 'about:blank';
              }
            } catch (e) { /* ignore parse errors */ }
          };
          window.addEventListener('beforeunload', ()=>{ try { es.close(); } catch(e){} });
        } catch (e) { /* ignore if SSE not available */ }
      }

      function initLayout() {
        const getSizes = (key, fallback) => {
          try {
            const raw = localStorage.getItem(key);
            if (!raw) return fallback;
            const arr = JSON.parse(raw);
            return Array.isArray(arr) && arr.length ? arr : fallback;
          } catch { return fallback; }
        };
        const saveSizes = (key, inst) => (sizes) => {
          try { localStorage.setItem(key, JSON.stringify(sizes)); } catch {}
        };

        // Shared helper to create a Split with persistence
        function createSplit({ ids, direction = 'horizontal', key, defaults, minSize, gutterSize = 6, snapOffset = 8, container }) {
          const sizes = getSizes(key, defaults);
          const inst = Split(ids, {
            direction,
            sizes,
            minSize,
            gutterSize,
            snapOffset,
            onDragEnd: saveSizes(key),
          });

          // Accessibility + keyboard support for gutters
          makeGuttersAccessible({ container, direction, split: inst, key, defaults });
          return inst;
        }

        function clamp(n, min, max) { return Math.max(min, Math.min(max, n)); }

        function makeGuttersAccessible({ container, direction, split, key, defaults }) {
          if (!container) return;
          const isHorizontal = direction !== 'vertical';
          const stepPct = 3; // resize step per keypress (in % of container)
          const gutters = container.querySelectorAll('.gutter' + (isHorizontal ? '.gutter-horizontal' : '.gutter-vertical'));
          gutters.forEach((g, index) => {
            g.setAttribute('tabindex', '0');
            g.setAttribute('role', 'separator');
            g.setAttribute('aria-orientation', isHorizontal ? 'vertical' : 'horizontal');
            g.setAttribute('aria-label', 'Resize ' + (isHorizontal ? 'columns' : 'panes'));

            // Double-click to reset
            g.addEventListener('dblclick', () => {
              split.setSizes(defaults);
              try { localStorage.setItem(key, JSON.stringify(defaults)); } catch {}
            });

            // Arrow keys to move this gutter
            g.addEventListener('keydown', (ev) => {
              const code = ev.key;
              const isDec = (isHorizontal && code === 'ArrowLeft') || (!isHorizontal && code === 'ArrowUp');
              const isInc = (isHorizontal && code === 'ArrowRight') || (!isHorizontal && code === 'ArrowDown');
              if (!isDec && !isInc) return;
              ev.preventDefault();
              const sizes = split.getSizes();
              // This gutter is between index and index+1
              const i = index;
              const delta = isInc ? stepPct : -stepPct;
              const left = clamp(sizes[i] + delta, 0, 100);
              const right = clamp(sizes[i + 1] - delta, 0, 100);
              const newSizes = sizes.slice();
              newSizes[i] = left;
              newSizes[i + 1] = right;
              // Normalize if sum drifted
              const sum = newSizes.reduce((a, b) => a + b, 0);
              if (sum !== 100) {
                const factor = 100 / sum;
                for (let k = 0; k < newSizes.length; k++) newSizes[k] = newSizes[k] * factor;
              }
              split.setSizes(newSizes);
              try { localStorage.setItem(key, JSON.stringify(newSizes)); } catch {}
            });
          });
        }

        // Create splits
        let hSplit = createSplit({
          ids: ['#col-left', '#col-center', '#col-right'],
          direction: 'horizontal',
          key: 'split-horizontal',
          defaults: [22, 53, 25],
          minSize: [180, 320, 220],
          container: document.getElementById('app'),
        });

        const lSplit = createSplit({
          ids: ['#left-history', '#left-clues'],
          direction: 'vertical',
          key: 'split-left',
          defaults: [50, 50],
          minSize: [120, 120],
          container: document.getElementById('left-split'),
        });

        const cSplit = createSplit({
          ids: ['#illustration', '#chat'],
          direction: 'vertical',
          key: 'split-center',
          defaults: [40, 60],
          minSize: [140, 240],
          container: document.getElementById('center-split'),
        });

        const rSplit = createSplit({
          ids: ['#right-stats-pane', '#right-skills-pane'],
          direction: 'vertical',
          key: 'split-right',
          defaults: [45, 55],
          minSize: [120, 140],
          container: document.getElementById('right-split'),
        });

        // Toggle horizontal split for small screens (matches CSS @media)
        function toggleHorizontalSplit() {
          const narrow = window.innerWidth <= 1000;
          const left = document.getElementById('col-left');
          const right = document.getElementById('col-right');
          if (narrow) {
            // Ensure split instance is destroyed so it stops sizing hidden panes
            if (hSplit && typeof hSplit.destroy === 'function') {
              try { hSplit.destroy(); } catch {}
              hSplit = null;
            }
          } else {
            if (!hSplit) {
              hSplit = createSplit({
                ids: ['#col-left', '#col-center', '#col-right'],
                direction: 'horizontal',
                key: 'split-horizontal',
                defaults: [22, 53, 25],
                minSize: [180, 320, 220],
                container: document.getElementById('app'),
              });
            }
          }
        }
        toggleHorizontalSplit();
        window.addEventListener('resize', () => { toggleHorizontalSplit(); });
      }

      async function init() {
        initLayout();
        const state = await fetchState();
        if (!state) return;
        renderHistory(state.history);
        renderClues(state.clues);
        renderIllustration(state.illustration_url);
        renderPC(state.pc);
        listenEvents();
        // Chat handled inside the embedded Chainlit iframe
      }

      // Helper: send a message into the embedded Chainlit chat iframe
      async function sendMessageToChat(text) {
        const iframe = document.querySelector('#chat iframe');
        if (!iframe) throw new Error('Chat iframe not found');

        // Wait until iframe document is ready
        const doc = await waitForIframeDocument(iframe, 8000);
        if (!doc) throw new Error('Chat iframe not ready');

        // Try to locate the composer input and a send button
        const { textbox, sendButton } = await findComposerElements(doc, 8000);
        if (!textbox && !sendButton) throw new Error('Chat composer not found');

        // Set the message text into the composer
        if (textbox) await setTextIntoComposer(textbox, text);

        // If there is a send button, wait for it to become enabled; if it doesn't, try nudges
        if (sendButton) {
          const enabled = await waitFor(() => isButtonEnabled(sendButton), 2000, 120);
          if (!enabled && textbox) {
            await nudgeComposer(textbox, text);
            // After nudging, wait a bit more
            await waitFor(() => isButtonEnabled(sendButton), 1500, 120);
          }
        }

        // Prefer clicking send button if present; otherwise simulate Enter in the textbox
        let sent = false;
        if (sendButton) {
          try { sendButton.click(); sent = true; } catch {}
        }
        if (!sent && textbox) {
          try {
            simulateEnterKey(textbox);
            sent = true;
          } catch {}
        }
        if (!sent) throw new Error('Unable to dispatch send action');
      }

      function waitForIframeDocument(iframe, timeoutMs = 8000) {
        return new Promise((resolve) => {
          const start = Date.now();
          const tick = () => {
            try {
              const doc = iframe.contentDocument || iframe.contentWindow?.document;
              if (doc && doc.readyState !== 'loading') {
                resolve(doc);
                return;
              }
            } catch (_) { /* cross-origin or not ready */ }
            if (Date.now() - start > timeoutMs) return resolve(null);
            setTimeout(tick, 150);
          };
          tick();
        });
      }

      async function findComposerElements(doc, timeoutMs = 8000) {
        const start = Date.now();
        const isVisible = (el) => !!el && el.offsetParent !== null;
        const pick = (list) => Array.from(list || []).find(isVisible) || null;
        while (Date.now() - start <= timeoutMs) {
          try {
            // Candidate selectors for the text input
            const textCandidates = [
              'textarea',
              'div[role="textbox"]',
              '[contenteditable="true"]',
              'textarea[placeholder]',
              'textarea[aria-label]',
            ];
            let textbox = null;
            for (const sel of textCandidates) {
              const el = pick(doc.querySelectorAll(sel));
              if (el) { textbox = el; break; }
            }

            // Candidate selectors for a send button
            const btnCandidates = [
              'button[title="Send"]',
              'button[aria-label="Send"]',
              'button[type="submit"]',
              'button:has(svg[aria-label="send"])',
              'button:has(svg[aria-label*="send"])',
              'button:has(svg[title*="send"])',
            ];
            let sendButton = null;
            for (const sel of btnCandidates) {
              const el = pick(doc.querySelectorAll(sel));
              if (el) { sendButton = el; break; }
            }

            if (textbox || sendButton) return { textbox, sendButton };
          } catch (_) { /* ignore transient errors while app hydrates */ }
          await new Promise(r => setTimeout(r, 200));
        }
        return { textbox: null, sendButton: null };
      }

      async function setTextIntoComposer(inputEl, text) {
        if (!inputEl) return;
        const isContentEditable = inputEl.getAttribute && inputEl.getAttribute('contenteditable') === 'true';
        if (isContentEditable) {
          inputEl.focus();
          // Prefer execCommand to mimic real typing for frameworks
          try {
            const sel = inputEl.ownerDocument.getSelection();
            if (sel) {
              sel.removeAllRanges();
              const range = inputEl.ownerDocument.createRange();
              range.selectNodeContents(inputEl);
              sel.addRange(range);
            }
            if (document.queryCommandSupported && document.execCommand) {
              document.execCommand('insertText', false, text);
            } else {
              inputEl.textContent = text;
            }
          } catch {
            inputEl.textContent = text;
          }
          dispatchInputEvent(inputEl, { inputType: 'insertFromPaste', data: text });
        } else {
          inputEl.focus();
          // Use native setter so React/Vue listeners get notified properly
          const tag = (inputEl.tagName || '').toUpperCase();
          const proto = tag === 'TEXTAREA' ? HTMLTextAreaElement.prototype : HTMLInputElement.prototype;
          const valueSetter = Object.getOwnPropertyDescriptor(proto, 'value')?.set;
          if (valueSetter) valueSetter.call(inputEl, text); else inputEl.value = text;
          dispatchInputEvent(inputEl, { inputType: 'insertFromPaste', data: text });
          inputEl.dispatchEvent(new Event('change', { bubbles: true }));
        }
        // Allow frameworks to sync internal state
        await new Promise(r => setTimeout(r, 50));
      }

      function simulateEnterKey(el) {
        const opts = { key: 'Enter', code: 'Enter', keyCode: 13, which: 13, bubbles: true };
        el.dispatchEvent(new KeyboardEvent('keydown', opts));
        el.dispatchEvent(new KeyboardEvent('keypress', opts));
        el.dispatchEvent(new KeyboardEvent('keyup', opts));
      }

      function dispatchInputEvent(el, { inputType = 'insertText', data = '' } = {}) {
        try {
          el.dispatchEvent(new InputEvent('input', { bubbles: true, cancelable: true, inputType, data }));
        } catch {
          el.dispatchEvent(new Event('input', { bubbles: true }));
        }
      }

      function isButtonEnabled(btn) {
        if (!btn) return false;
        if (btn.disabled) return false;
        const aria = btn.getAttribute('aria-disabled');
        if (aria === 'true') return false;
        const cls = btn.className || '';
        if (/\bdisabled\b/.test(cls)) return false;
        return true;
      }

      function waitFor(predicate, timeoutMs = 1000, intervalMs = 100) {
        return new Promise((resolve) => {
          const start = Date.now();
          const tick = () => {
            try {
              if (predicate()) return resolve(true);
            } catch { /* ignore */ }
            if (Date.now() - start > timeoutMs) return resolve(false);
            setTimeout(tick, intervalMs);
          };
          tick();
        });
      }

      async function nudgeComposer(inputEl, finalText) {
        // A series of small actions to wake up reactive listeners
        try { inputEl.focus(); } catch {}
        await new Promise(r => setTimeout(r, 30));

        const isContentEditable = inputEl.getAttribute && inputEl.getAttribute('contenteditable') === 'true';
        if (isContentEditable) {
          // Type a space then delete it
          try {
            document.execCommand && document.execCommand('insertText', false, finalText + ' ');
          } catch {
            inputEl.textContent = (inputEl.textContent || '') + ' ';
          }
          dispatchInputEvent(inputEl, { inputType: 'insertText', data: ' ' });
          await new Promise(r => setTimeout(r, 40));
          // Remove the space
          try { document.execCommand && document.execCommand('delete'); } catch {
            inputEl.textContent = (inputEl.textContent || '').replace(/\s$/, '');
          }
          dispatchInputEvent(inputEl, { inputType: 'deleteContentBackward', data: '' });
        } else {
          const tag = (inputEl.tagName || '').toUpperCase();
          const proto = tag === 'TEXTAREA' ? HTMLTextAreaElement.prototype : HTMLInputElement.prototype;
          const setter = Object.getOwnPropertyDescriptor(proto, 'value')?.set;
          const curr = inputEl.value || finalText || '';
          if (setter) setter.call(inputEl, curr + ' '); else inputEl.value = curr + ' ';
          dispatchInputEvent(inputEl, { inputType: 'insertText', data: ' ' });
          await new Promise(r => setTimeout(r, 40));
          if (setter) setter.call(inputEl, finalText); else inputEl.value = finalText;
          dispatchInputEvent(inputEl, { inputType: 'deleteContentBackward', data: '' });
          inputEl.dispatchEvent(new Event('change', { bubbles: true }));
        }

        // Blur and refocus to force validations
        try { inputEl.blur(); } catch {}
        await new Promise(r => setTimeout(r, 30));
        try { inputEl.focus(); } catch {}
        await new Promise(r => setTimeout(r, 30));
      }

      init();
    </script>
  </body>
  </html>
